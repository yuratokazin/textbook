# 3.1 Форматы изображений (JPEG, PNG, SVG, WebP) для веба.

Выбор правильного формата изображения критически важен для производительности и качества веб-сайта. Давайте разберем основные форматы.

---

### **Ключевые критерии выбора формата**

1.  **Тип изображения** (фотография, графика, логотип)
2.  **Необходимость прозрачности**
3.  **Качество vs Размер файла**
4.  **Анимация**
5.  **Поддержка браузерами**

---

### **1. JPEG (Joint Photographic Experts Group)**

#### **Характеристики:**
- **Сжатие:** С потерями (можно регулировать качество)
- **Прозрачность:** ❌ Не поддерживает
- **Анимация:** ❌ Не поддерживает
- **Лучше всего подходит для:** Фотографий, сложных градиентов

#### **Когда использовать:**
- Фотографии реального мира
- Изображения с большим количеством цветов и деталей
- Ситуации, когда важнее маленький размер файла, чем идеальное качество

#### **Пример кода:**
```html
<img src="photo.jpg" alt="Пейзаж" width="800" height="600">
```

#### **Настройка качества:**
```css
/* В CSS нельзя управлять качеством JPEG */
/* Но можно указать разные изображения для разных разрешений */
.hero-image {
    background-image: url('photo-high-quality.jpg');
}

@media (max-width: 768px) {
    .hero-image {
        background-image: url('photo-low-quality.jpg');
    }
}
```

---

### **2. PNG (Portable Network Graphics)**

#### **Характеристики:**
- **Сжатие:** Без потерь
- **Прозрачность:** ✅ Поддерживает (альфа-канал)
- **Анимация:** ❌ Не поддерживает (но есть APNG)
- **Лучше всего подходит для:** Логотипов, графиков, скриншотов

#### **Разновидности:**
- **PNG-8:** До 256 цветов, базовая прозрачность (да/нет)
- **PNG-24:** Миллионы цветов, плавная прозрачность
- **PNG-32:** Технически то же, что PNG-24 с альфа-каналом

#### **Когда использовать:**
- Изображения с прозрачностью
- Логотипы и иконки
- Скриншоты интерфейсов
- Простая графика с четкими границами

#### **Пример:**
```html
<!-- Логотип с прозрачным фоном -->
<img src="logo.png" alt="Логотип компании" width="200" height="80">
```

---

### **3. SVG (Scalable Vector Graphics)**

#### **Характеристики:**
- **Тип:** Векторный (на основе XML)
- **Прозрачность:** ✅ Поддерживает
- **Анимация:** ✅ Поддерживает (CSS/JavaScript)
- **Масштабирование:** ✅ Без потерь при любом размере
- **Лучше всего подходит для:** Иконок, логотипов, простой графики

#### **Преимущества:**
- Бесконечное масштабирование без потери качества
- Маленький размер файла для простой графики
- Возможность стилизации через CSS
- Доступность для SEO (текст остается текстом)

#### **Когда использовать:**
- Иконки и пиктограммы
- Логотипы
- Простые иллюстрации
- Графики и диаграммы

#### **Способы использования:**

**Как файл:**
```html
<img src="icon.svg" alt="Иконка" width="32" height="32">
```

**Inline SVG (прямо в HTML):**
```html
<svg width="100" height="100" viewBox="0 0 100 100">
    <circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />
</svg>
```

**CSS background:**
```css
.icon {
    background-image: url('icon.svg');
    width: 24px;
    height: 24px;
}
```

---

### **4. WebP (Modern Web Format)**

#### **Характеристики:**
- **Сжатие:** С потерями и без потерь
- **Прозрачность:** ✅ Поддерживает
- **Анимация:** ✅ Поддерживает
- **Размер файла:** На 25-35% меньше, чем PNG/JPEG
- **Лучше всего подходит для:** Замена JPEG и PNG

#### **Преимущества:**
- Значительно меньший размер при том же качестве
- Поддержка прозрачности (как PNG)
- Поддержка анимации (как GIF)
- Современный формат от Google

#### **Когда использовать:**
- Фотографии (вместо JPEG)
- Графика с прозрачностью (вместо PNG)
- Анимированные изображения (вместо GIF)

#### **Поддержка браузерами:**
> ✅ Chrome, Firefox, Edge, Opera  
> ✅ Safari (с версии 14)  
> ❌ Старые браузеры (нужен fallback)

#### **Пример с fallback:**
```html
<picture>
    <source srcset="image.webp" type="image/webp">
    <source srcset="image.jpg" type="image/jpeg">
    <img src="image.jpg" alt="Описание изображения">
</picture>
```

---

### **Сравнительная таблица**

| Формат | Тип | Прозрачность | Анимация | Лучшее применение |
|--------|-----|--------------|----------|-------------------|
| **JPEG** | Растровый | ❌ | ❌ | Фотографии |
| **PNG** | Растровый | ✅ | ❌ | Логотипы, графика с прозрачностью |
| **SVG** | Векторный | ✅ | ✅ | Иконки, логотипы, простая графика |
| **WebP** | Растровый | ✅ | ✅ | Универсальный (замена JPEG/PNG) |

---

### **Практические рекомендации**

#### **1. Современный подход:**
```html
<picture>
    <!-- Сначала пробуем самый современный формат -->
    <source srcset="photo.avif" type="image/avif">
    <source srcset="photo.webp" type="image/webp">
    <!-- Fallback для старых браузеров -->
    <source srcset="photo.jpg" type="image/jpeg">
    <img src="photo.jpg" alt="Описание" loading="lazy">
</picture>
```

#### **2. Для фоновых изображений в CSS:**
```css
.hero {
    background-image: url('photo.jpg');
}

/* Modern browsers */
@supports (background-image: url('photo.webp')) {
    .hero {
        background-image: url('photo.webp');
    }
}
```

#### **3. Оптимизация производительности:**
```html
<!-- Lazy loading для изображений ниже скролла -->
<img src="image.jpg" alt="Описание" loading="lazy" width="800" height="600">

<!-- Указание размеров для предотвращения layout shift -->
<img src="image.jpg" alt="Описание" width="800" height="600">
```

---

### **Бонус: AVIF - формат будущего**

- **Еще на 20-30% меньше**, чем WebP
- **Лучшее качество** при том же размере
- Поддержка **HDR** и **широкой цветовой гаммы**
- Постепенно набирает поддержку в браузерах

```html
<picture>
    <source srcset="image.avif" type="image/avif">
    <source srcset="image.webp" type="image/webp">
    <img src="image.jpg" alt="Описание">
</picture>
```

**Итог:** Начинайте с WebP как основного формата с fallback на JPEG/PNG, используйте SVG для векторной графики, и следите за развитием AVIF!

---
---

# 3.2 Работа с макетами в Figma: извлечение данных, работа со слоями.

Отлично! Figma стала стандартом в веб-дизайне, и умение работать с макетами — критически важный навык для фронтенд-разработчика. Давайте разберем, как эффективно извлекать данные и работать со слоями.

---

### **Основы интерфейса Figma**

Прежде чем работать с макетом, понимайте его структуру:

- **Монтажные области (Frames)** — контейнеры для дизайна (аналоги `div` или `section` в HTML)
- **Слои (Layers)** — все элементы на монтажной области
- **Группы (Groups)** — объединенные слои
- **Компоненты (Components)** — переиспользуемые элементы (кнопки, карточки)

---

### **Извлечение данных для верстки**

#### **1. Получение размеров и отступов**

**Простой способ:**
1. Выделите элемент
2. На панели справа в разделе **Design** смотрите:
   - `W` (width) и `H` (height) — ширина и высота
   - `X` и `Y` — позиция относительно монтажной области

**Точные измерения между элементами:**
1. Зажмите `Alt` (Option на Mac)
2. Наведите курсор на расстояние между элементами
3. Figma покажет точное расстояние в пикселях

```css
/* Пример: измеряем отступ между кнопкой и текстом */
.button {
    margin-top: 24px; /* Расстояние, которое показала Figma */
}
```

#### **2. Извлечение цветов**

1. Выделите элемент
2. В разделе **Fill** на панели справа кликните на цветной квадрат
3. Figma покажет цвет в разных форматах:

```css
/* HEX (самый частый в вебе) */
color: #2D5BFF;

/* RGB */
color: rgb(45, 91, 255);

/* RGBA (с прозрачностью) */
color: rgba(45, 91, 255, 0.8);

/* HSL (современный CSS) */
color: hsl(229, 100%, 59%);
```

**Совет:** Копируйте цвет прямо из Figma сочетанием клавиш `Ctrl+C` при выделенном цвете.

#### **3. Работа со шрифтами**

1. Выделите текстовый слой
2. В разделе **Text** смотрите:

```css
.font-family {
    font-family: "Inter", sans-serif; /* Название шрифта */
    font-size: 16px;                  /* Размер */
    font-weight: 500;                 /* Насыщенность (Regular, Medium, Bold) */
    line-height: 24px;                /* Межстрочный интервал */
    letter-spacing: 0.5px;            /* Межбуквенный интервал */
    text-align: left;                 /* Выравнивание */
}
```

**Важно:** Если шрифт не системный, дизайнер должен предоставить файлы шрифтов или ссылку на Google Fonts.

#### **4. Извлечение тени (Shadow)**

1. Выделите элемент с тенью
2. В разделе **Effects** смотрите параметры:

```css
.box {
    /* Figma: X=0, Y=4, Blur=8, Spread=0, Color=#000000 с 10% opacity */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    
    /* Более сложная тень */
    /* Figma: X=0, Y=8, Blur=24, Spread=0, Color=#000000 с 16% opacity */
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.16);
}
```

#### **5. Работа с градиентами**

```css
.element {
    /* Линейный градиент */
    background: linear-gradient(90deg, #FF6B6B 0%, #4ECDC4 100%);
    
    /* Радиальный градиент */
    background: radial-gradient(circle, #FF6B6B 0%, #4ECDC4 100%);
}
```

---

### **Работа со слоями**

#### **1. Навигация по слоям**

- **Панель слоев (Layers Panel)** слева показывает иерархию
- Используйте `Ctrl+/` (Cmd+/ на Mac) для поиска по слоям
- Раскрывайте группы (`▶`) чтобы увидеть вложенные элементы

#### **2. Понимание структуры**

**Пример макета в Figma:**
```
Frame: Website Header (макет)
├── Group: Navigation (группа)
│   ├── Logo (image)
│   ├── Menu Items (text)
│   └── Button (component)
└── Group: Hero Content (группа)
    ├── H1: Main Title (text)
    ├── P: Description (text)
    └── CTA Button (component)
```

**Как это превращается в HTML:**
```html
<header class="header">
    <nav class="nav">
        <img src="logo.svg" alt="Logo" class="nav__logo">
        <ul class="nav__menu">
            <li><a href="#">Home</a></li>
            <li><a href="#">About</a></li>
        </ul>
        <button class="btn">Contact</button>
    </nav>
    <div class="hero">
        <h1 class="hero__title">Main Title</h1>
        <p class="hero__description">Description text</p>
        <button class="btn btn--primary">Get Started</button>
    </div>
</header>
```

#### **3. Именование слоев**

Хороший дизайнер называет слои осмысленно:
- `btn-primary` вместо `Rectangle 234`
- `header-navigation` вместо `Group 12`

Если слои плохо названы — переименуйте их для удобства работы!

#### **4. Работа с компонентами**

- **Основной компонент (Main Component)** — оригинал
- **Экземпляр (Instance)** — копия компонента

При изменении основного компонента все экземпляры обновляются автоматически.

---

### **Практический workflow верстки**

#### **1. Подготовка**
- Изучите весь макет целиком
- Проверьте наличие всех состояний элементов (hover, active, disabled)
- Уточните у дизайнера непонятные моменты

#### **2. Анализ структуры**
```css
/* Сначала создаем структурные блоки */
.header { /* стили */ }
.nav { /* стили */ }
.hero { /* стили */ }
.footer { /* стили */ }
```

#### **3. Извлечение стилей**
```css
/* Затем извлекаем конкретные стили */
.hero__title {
    font-family: "Inter", sans-serif;
    font-size: 48px;
    font-weight: 700;
    line-height: 1.2;
    color: #1A1A1A;
    margin-bottom: 24px;
}
```

#### **4. Проверка адаптива**
- Спросите у дизайнера про мобильную версию
- Проверьте breakpoints в Figma (если есть)
- Измеряйте отступы для разных разрешений

---

### **Полезные советы и хитрости**

1. **Автоматизация:** Используйте плагины для автоматического экспорта кода (Figma to HTML/CSS)
2. **Pixel Perfect:** Включите режим пиксельной сетки (View > Show Pixel Grid)
3. **Единицы измерения:** Убедитесь, что в макете используются пиксели (px), а не pt
4. **Экспорт assets:**
   - Выделите элемент
   - Нажмите Export на панели справа
   - Выберите формат (SVG для иконок, PNG для сложной графики)
   - Укажите плотность (1x, 2x, 3x для ретины)

5. **Состояния элементов:** Проверьте все состояния:
   - `:hover`
   - `:active` 
   - `:focus`
   - `:disabled`

**Итог:** Figma — мощный инструмент для collaboration между дизайнерами и разработчиками. Освоив работу со слоями и извлечение данных, вы значительно ускорите процесс верстки и избежите многих ошибок. Всегда уточняйте непонятные моменты у дизайнера — это сэкономит время всем!

---
---
---

# 3.3 Браузерные инструменты разработчика (DevTools).

Браузерные инструменты разработчика (DevTools) — это мощный набор инструментов, встроенный прямо в браузер, который позволяет анализировать, отлаживать и тестировать веб-страницы. Давайте разберем основные возможности.

---

### **Как открыть DevTools?**

- **F12** — универсальная клавиша для большинства браузеров
- **Ctrl+Shift+I** (Cmd+Option+I на Mac)
- **Правая кнопка мыши → "Просмотреть код" / "Inspect"**
- **Ctrl+Shift+J** (Cmd+Option+J) — сразу открывает Console

---

### **Основные вкладки и их назначение**

#### **1. Elements (Элементы) / Inspector (Инспектор)**

**Что показывает:** Дерево DOM и CSS-стили текущей страницы.

**Ключевые возможности:**

- **Инспектирование элементов:** Наведите курсор на любой элемент в DOM — он подсветится на странице
- **Редактирование HTML:** Двойной клик по любому элементу позволяет изменить его прямо в браузере
- **Просмотр и изменение CSS:** В правой панели видны все примененные стили
- **Добавление новых стилей:** Можно писать CSS прямо в браузере

```css
/* Пример: быстро тестируем стили в DevTools */
.button {
    background-color: #007bff; /* Меняем цвет */
    padding: 12px 24px;       /* Изменяем отступы */
    border-radius: 8px;       /* Добавляем скругление */
}
```

**Практическое применение:**
- Быстрое прототипирование стилей
- Поиск проблем с наследованием CSS
- Тестирование медиа-запросов

#### **2. Console (Консоль)**

**Что показывает:** JavaScript ошибки, предупреждения, логи выполнения кода.

**Ключевые возможности:**
- **Выполнение JS-кода:** Пишите и запускайте JavaScript прямо в консоли
- **Отладка:** `console.log()`, `console.error()`, `console.warn()`
- **Инспекция переменных:** Просто введите имя переменной и нажмите Enter

```javascript
// Пример работы в консоли
const buttons = document.querySelectorAll('.button');
console.log(buttons); // Посмотрим все найденные кнопки

// Быстро тестируем функцию
function testAlert() {
    alert('DevTools работают!');
}
testAlert();
```

#### **3. Sources (Источники)**

**Что показывает:** Исходные файлы проекта (HTML, CSS, JS).

**Ключевые возможности:**
- **Отладка JavaScript:** Точки останова (breakpoints), пошаговое выполнение
- **Работа с файлами:** Просмотр и редактирование исходного кода
- **Snippets:** Создание и выполнение сниппетов кода

**Процесс отладки:**
1. Найдите ваш JS-файл
2. Установите точку останова (клик на номер строки)
3. Обновите страницу — выполнение остановится в этой строке
4. Используйте шаги: Step Over, Step Into, Step Out

#### **4. Network (Сеть)**

**Что показывает:** Все сетевые запросы страницы.

**Ключевые возможности:**
- **Анализ загрузки:** Видите размер и время загрузки каждого ресурса
- **Просмотр заголовков:** Request/Response headers
- **Мониторинг API-запросов:** XHR/Fetch запросы
- **Throttling:** Эмуляция медленного соединения (3G, Slow 4G)

**Практическое применение:**
```javascript
// Пример: анализируем API-запрос
// В Network видим:
// - URL: /api/users
// - Method: GET
// - Status: 200
// - Size: 15.2 KB
// - Time: 240ms
```

#### **5. Performance (Производительность)**

**Что показывает:** Детальная информация о производительности страницы.

**Ключевые возможности:**
- **Запись производительности:** Анализ FPS, CPU использования
- **Визуализация рендеринга:** Painting, Layout, Compositing
- **Выявление узких мест:** Поиск "тяжелых" функций JavaScript

**Как использовать:**
1. Нажмите "Record"
2. Выполните действия на странице
3. Остановите запись и анализируйте результаты

#### **6. Application (Приложение)**

**Что показывает:** Данные о клиентском хранилище.

**Ключевые возможности:**
- **Local Storage / Session Storage:** Просмотр и редактирование
- **Cookies:** Работа с куками
- **Cache Storage:** Просмотр кэшированных ресурсов (PWA)
- **IndexedDB:** Работа с клиентской базой данных

```javascript
// Пример: проверяем Local Storage
// В Application -> Local Storage видим:
// key: "userToken", value: "abc123xyz"
// Можем редактировать прямо в DevTools
```

#### **7. Lighthouse**

**Что показывает:** Автоматический аудит качества веб-страницы.

**Проверяемые метрики:**
- **Performance** (Производительность)
- **Accessibility** (Доступность)
- **Best Practices** (Передовые практики)
- **SEO** (Поисковая оптимизация)
- **PWA** (Прогрессивные веб-приложения)

---

### **Практические сценарии использования**

#### **1. Адаптивная верстка**
- **Ctrl+Shift+M** — режим адаптивного дизайна
- Тестирование на разных разрешениях
- Эмуляция touch-устройств

#### **2. Отладка CSS**
```css
/* В Elements находим проблемный элемент */
.container {
    display: flex; /* Видим, что flex не применяется */
    /* DevTools покажет: свойство перечеркнуто */
    /* Смотрим, какой селектор имеет более высокую специфичность */
}
```

#### **3. Оптимизация загрузки**
- В Network находим самые большие файлы
- Анализируем, какие ресурсы блокируют загрузку
- Проверяем кэширование

#### **4. Работа с цветами**
- Клик на цветном квадрате в Styles
- Палитра цветов прямо в браузере
- Быстрое копирование значений HEX/RGB

#### **5. Тестирование JavaScript**
```javascript
// В Console тестируем селекторы
document.querySelector('.button'); // Проверяем, находится ли элемент
$0 // Ссылка на последний выбранный в Elements элемент
```

---

### **Полезные сочетания клавиш**

- **Ctrl+Shift+C** — быстрый инспектор элементов
- **Ctrl+Shift+F** — поиск по всем файлам
- **Ctrl+P** — быстрый переход к файлу
- **Ctrl+Shift+E** — экспорт изменений из DevTools

---

### **Советы для эффективной работы**

1. **Используйте $0:** В консоли `$0` ссылается на последний выбранный элемент
2. **Сохраняйте изменения:** В Sources можно сохранить изменения прямо в файловой системе
3. **Работайте с breakpoints:** Умные точки останова (DOM, XHR, Event Listeners)
4. **Мониторьте память:** Performance → Memory для поиска утечек памяти
5. **Тестируйте доступность:** Accessibility панель в Elements

**Пример workflow отладки:**
1. Обнаружили баг на странице
2. Открыли Elements → находим проблемный элемент
3. В Console тестируем возможные решения
4. Редактируем стили в Elements
5. Когда нашли решение — переносим код в исходные файлы

DevTools — ваш лучший друг в веб-разработке. Регулярное использование этих инструментов значительно ускорит процесс разработки и отладки!

---
---
---
---

# 3.4 Основы системы контроля версий Git.

Отлично! Git — это система контроля версий, которая является обязательным инструментом в арсенале любого разработчика. Давайте разберем основы.

---

### **Что такое Git и зачем он нужен?**

**Git** — это распределенная система контроля версий, которая:

- ✅ Сохраняет историю изменений в вашем проекте
- ✅ Позволяет откатываться к предыдущим версиям
- ✅ Обеспечивает командную работу без конфликтов
- ✅ Создает "резервные копии" вашего кода

**Без Git:**
- `project_final.html`
- `project_final_v2.html` 
- `project_REAL_final.html`
- `project_last_version.html`

**С Git:** У вас одна папка проекта и полная история всех изменений!

---

### **Основные понятия**

#### **1. Репозиторий (Repository)**
- Локальный (на вашем компьютере)
- Удаленный (на GitHub, GitLab, Bitbucket)

#### **2. Коммит (Commit)**
- "Снимок" вашего проекта в определенный момент времени
- Каждый коммит имеет уникальный хеш (например, `a1b2c3d`)

#### **3. Ветка (Branch)**
- Отдельная линия разработки
- По умолчанию создается ветка `main` (или `master`)

---

### **Базовый workflow работы с Git**

#### **1. Инициализация репозитория**

```bash
# Переходим в папку проекта
cd my-project

# Инициализируем Git репозиторий
git init
```

#### **2. Проверка статуса**

```bash
# Показывает текущее состояние репозитория
git status

# Показывает изменения в файлах
git diff
```

#### **3. Добавление файлов в отслеживание**

```bash
# Добавляем конкретный файл
git add index.html

# Добавляем все файлы в текущей директории
git add .

# Добавляем все измененные файлы
git add -A
```

#### **4. Создание коммита**

```bash
# Создаем коммит с сообщением
git commit -m "Добавлена главная страница"

# Более подробное сообщение
git commit -m "feat: добавить главную страницу

- Создана структура HTML
- Добавлены базовые стили CSS
- Реализована навигация"
```

#### **5. Просмотр истории**

```bash
# Показывает историю коммитов
git log

# Краткая история
git log --oneline

# История с графиком веток
git log --oneline --graph --all
```

---

### **Работа с удаленными репозиториями**

#### **1. Привязка к удаленному репозиторию**

```bash
# Добавляем удаленный репозиторий (обычно на GitHub)
git remote add origin https://github.com/username/my-project.git

# Проверяем удаленные репозитории
git remote -v
```

#### **2. Отправка изменений на сервер**

```bash
# Отправляем изменения в ветку main
git push -u origin main

# Все последующие пуши можно делать просто
git push
```

#### **3. Загрузка изменений с сервера**

```bash
# Скачиваем последние изменения
git pull
```

---

### **Работа с ветками**

#### **1. Создание и переключение веток**

```bash
# Создаем новую ветку
git branch feature/header

# Переключаемся на ветку
git checkout feature/header

# Или одной командой (создание + переключение)
git checkout -b feature/header
```

#### **2. Слияние веток**

```bash
# Переключаемся в main
git checkout main

# Вливаем изменения из feature/header в main
git merge feature/header
```

#### **3. Удаление веток**

```bash
# Удаляем локальную ветку
git branch -d feature/header

# Удаляем удаленную ветку
git push origin --delete feature/header
```

---

### **Типичные сценарии работы**

#### **Сценарий 1: Начало работы с существующим проектом**

```bash
# Клонируем репозиторий
git clone https://github.com/username/project.git

# Переходим в папку
cd project

# Создаем свою ветку для задачи
git checkout -b feature/my-feature
```

#### **Сценарий 2: Ежедневная работа над задачей**

```bash
# Перед началом работы - забираем свежие изменения
git pull origin main

# Пишем код, создаем/меняем файлы...

# Проверяем что изменилось
git status

# Добавляем изменения
git add .

# Создаем коммит
git commit -m "feat: реализовать функционал кнопки"

# Отправляем на сервер
git push origin feature/my-feature
```

#### **Сценарий 3: Завершение задачи**

```bash
# Переключаемся в main
git checkout main

# Забираем последние изменения
git pull origin main

# Возвращаемся в свою ветку
git checkout feature/my-feature

# Вливаем актуальный main в нашу ветку
git merge main

# Решаем конфликты (если есть)
# ...

# Переключаемся в main
git checkout main

# Вливаем нашу ветку
git merge feature/my-feature

# Отправляем изменения
git push origin main

# Удаляем ветку (если она больше не нужна)
git branch -d feature/my-feature
```

---

### **Решение конфликтов**

Конфликт возникает когда Git не может автоматически объединить изменения.

**Пример конфликта:**
```css
/* В вашей ветке */
.header {
<<<<<<< HEAD
    background: blue;
    color: white;
=======
    background: red;
    font-size: 18px;
>>>>>>> feature/header
}
```

**Решение:**
1. Открываем файл в редакторе
2. Выбираем нужные изменения (или комбинируем их)
3. Удаляем маркеры конфликта (`<<<<<<<`, `=======`, `>>>>>>>`)
4. Сохраняем файл
5. Добавляем исправленный файл и создаем коммит

```bash
# После решения конфликтов
git add style.css
git commit -m "resolve: исправить конфликт в стилях заголовка"
```

---

### **Полезные команды для повседневной работы**

```bash
# Просмотр изменений в конкретном файле
git diff filename.html

# Отмена изменений в файле (до добавления в staged)
git checkout -- filename.html

# Удаление файла из индекса (но сохранение в рабочей директории)
git reset filename.html

# Временное сохранение изменений без коммита
git stash

# Возврат временно сохраненных изменений
git stash pop
```

---

### **Соглашения по коммитам**

Хорошие сообщения коммитов:
- `feat: добавить авторизацию пользователя`
- `fix: исправить баг с кнопкой отправки`
- `docs: обновить README`
- `style: форматировать код согласно ESLint`
- `refactor: переписать модуль аутентификации`

**Плохие сообщения:**
- `сделал что-то`
- `еще изменения`
- `123`

---

### **Типичная структура папки проекта с Git**

```
my-project/
├── .git/               # Папка Git (не трогать!)
├── index.html
├── styles/
│   └── style.css
├── scripts/
│   └── app.js
├── .gitignore          # Файл с исключениями
└── README.md
```

**Файл .gitignore:**
```
# Игнорируем node_modules
node_modules/

# Игнорируем логи
*.log

# Игнорируем системные файлы
.DS_Store
Thumbs.db

# Игнорируем environment variables
.env
```

---

### **Итог**

**Базовый workflow:**
1. `git pull` — забрать свежие изменения
2. **Пишем код**
3. `git add .` — добавляем изменения
4. `git commit -m "сообщение"` — фиксируем изменения
5. `git push` — отправляем на сервер

**Ключевые преимущества Git:**
- 📝 Полная история изменений
- 🔄 Легкий откат к любой версии
- 👥 Эффективная командная работа
- 🛡️ Надежное резервное копирование

**Следующий шаг:** Зарегистрируйтесь на GitHub и создайте свой первый репозиторий!



